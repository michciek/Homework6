{
    "contents" : "## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n## Advanced Data Analysis Software Development with R - Batch 1\n## Homework 5\n##\n## Student:       Paw?owski Micha?\n## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nlibrary(Rcpp); library(inline); library(roxygen2); library(devtools); library(testthat)\n## ------------------------ Exercise 05.01 ----------------------------\n\n## ---- Documentation ----\n\n# DESCRIPTION\n# This function computes the length of the longest common subsequence of two numeric vectors.\n#\n# ARGUMENTS\n# x - a numeric vector\n# y - a numeric vector\n#\n# RETURN VALUE\n# The function returns the longest common subsequence of two numeric vectors x and y.\n\n## ---- Function ----\n\nRcpp::cppFunction(\"\n  /*  The function uses the widely known algorithm for the longest common sequence's length */\n\n  int lcs(const NumericVector x, const NumericVector y) {\n    int n = x.size();\n    int m = y.size();\n    int tab[n+1][m+1];\n    for (int i=0; i<=n; i++) {\n      if (R_IsNA(x[i])) \n        return NA_REAL;  \n      for (int j=0; j<=m; j++) {\n        if (R_IsNA(y[j])) \n          return NA_REAL; \n        if (i == 0 || j == 0)\n          tab[i][j] = 0;\n        else if (x[i-1] == y[j-1])\n          tab[i][j] = tab[i-1][j-1] + 1;\n        else\n          tab[i][j] = R::fmax2(tab[i-1][j], tab[i][j-1]);\n      }\n    }\n    return tab[n][m];\n  }\n\")\n\n## ---- Examples ----\n\nexpect_that(lcs(c(1,2,3), c(3,4,5)), equals(1)) \n# the reversed order\nexpect_that(lcs(c(1,2,3), c(3,2,1)), equals(1))\nexpect_that(lcs(c(1,1,1,1,1), c(1,1,1)), equals(3))\nsam <- sample(1:10, 7)\n# the same elements\nexpect_that(lcs(sam, sam), equals(length(sam)))\nexpect_that(lcs(c(5,2,8,4,3,2,7,6), c(9,7,6,2,6,3,6)), equals(3)) \n# no common terms\nexpect_that(lcs(c(1,2,3), c(4,5,6)), equals(0)) \n# non-numeric input\nexpect_that(lcs(c(\"a\",\"b\",\"c\"), c(\"b\")), throws_error()) \n# handling NA according to op(NA) == NA\nlcs(c(1,2,3), c(3,2,NA))\nlcs(c(1,2,NA), c(3,2,1))\n# incorrect number of arguments\nexpect_that(lcs(c(1,2,3)), throws_error()) \n# Inf, NULL are considered as numbers\nexpect_that(lcs(c(1,2,3), c(1,3,Inf)), equals(2))\nexpect_that(lcs(c(1,2,3), c(1,3,NULL)), equals(2))\n## ------------------------ Exercise 05.02 ----------------------------\n\n## ---- Documentation ----\n\n# DESCRIPTION\n# This function merges two already sorted (nondecreasingly\n# or nonincreasingly - two cases are possible) numeric vectors into a one, sorted vector.\n#\n# ARGUMENTS\n# x - a numeric vector\n# y - a numeric vector\n#\n# RETURN VALUE\n# z - a sorted numeric vector which combines x and y \n\n## ---- Function ----\n\nRcpp::cppFunction('\n  NumericVector sortedmerge(const NumericVector x, const NumericVector y) {\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int n = x.size();\n    int m = y.size();\n    NumericVector z(n+m);\n    if ((x[0] <= x[n-1] && n > 1) || (y[0] <= y[m-1] && n==1)) { //nondecreasing case \n      while (i < n && j < m) {\n        if (x[i] <= y[j]) {\n          z[k] = x[i];\n          i++;\n        } else {\n          z[k] = y[j];\n          j++;\n        }\n        if (R_IsNA(z[k])) {\n          Rcpp::stop(\"Wrong input\");\n        }\n        k++;\n      }\n      if (i < n) { //vector y is finished, we fill the merged vector with elements of x to the end\n        for (int p = i; p < n; p++) {\n          z[k] = x[p];\n          if (R_IsNA(z[k])) {\n            Rcpp::stop(\"Wrong input\");\n          }\n          k++;\n        }\n      } else { //vector x is finished, we fill the merged vector with elements of y to the end\n        for (int p = j; p < m; p++) {\n          z[k] = y[p];\n          if (R_IsNA(z[k])) {\n            Rcpp::stop(\"Wrong input\");\n          }\n          k++;\n        }\n      }   \n    } else { //nonincreasing case\n      while (i < n && j < m) {\n        if (x[i] >= y[j]) {\n          z[k] = x[i];\n          i++;\n        } else {\n          z[k] = y[j];\n          j++;\n        }\n        if (R_IsNA(z[k])) {\n          Rcpp::stop(\"Wrong input\");\n        }\n        k++;\n      }\n      if (i < n) {\n        for (int p = i; p < n; p++) {\n          z[k] = x[p];\n          if (R_IsNA(z[k])) {\n            Rcpp::stop(\"Wrong input\");\n          }\n          k++;\n        }\n      } else {\n        for (int p = j; p < m; p++) {\n          z[k] = y[p];\n          if (R_IsNA(z[k])) {\n            Rcpp::stop(\"Wrong input\");\n          }\n          k++;\n        }\n      }   \n    }\n  return z;\n  }\n')\n## ---- Examples ----\n\nvec1 <- c(1,3,5,7,9,11); vec2 <- c(0,2,4,6,8,10)\nexpect_that(sortedmerge(vec1, vec2), equals(0:11)) \n# one elements' cases\nvec1 <- 1; vec2 <- c(3,2)\nexpect_that(sortedmerge(vec1, vec2), equals(c(3,2,1)))\nvec1 <- c(3,2); vec2 <- 1\nexpect_that(sortedmerge(vec1, vec2), equals(c(3,2,1)))\nvec1 <- c(2,3); vec2 <- 1\nexpect_that(sortedmerge(vec1, vec2), equals(c(1,2,3)))\nvec1 <- 2; vec2 <- c(1,3)\nexpect_that(sortedmerge(vec1, vec2), equals(c(1,2,3)))\n# NA's handling\nvec1 <- c(1,3,5,7,9,NA); vec2<- c(0,2,4,6,8,10)\nexpect_that(sortedmerge(vec1, vec2), throws_error())\n# incorrect number of arguments\nexpect_that(sortedmerge(vec1), throws_error())\n# decreasing case\nvec1 <- c(11,9,7,5,3,1); vec2<- c(10,8,6,4,2,0)\nexpect_that(sortedmerge(vec1, vec2), equals(11:0)) \n# infinity\nvec1 <- c(11,9,7,5,3,1); vec2<- c(Inf,10,8,6,4,2,0)\nexpect_that(sortedmerge(vec1, vec2), equals(c(Inf,11:0))) \nvec1 <- c(Inf,11,9,7,5,3,1); vec2<- c(Inf,10,8,6,4,2,0)\nexpect_that(sortedmerge(vec1, vec2), equals(c(Inf,Inf,11:0))) \n# NULL's handling\nvec1 <- c(1,3,5,7,9,11); vec2<- c(0,2,4,6,8,10,NULL)\nexpect_that(sortedmerge(vec1, vec2), equals(0:11)) \n# character's input\nvec1 <- c(\"a\", \"b\"); vec2 <- c(\"a\", \"c\")\nexpect_that(sortedmerge(vec1, vec2), throws_error())\n# not integer case\nvec1 <- c(exp(1),pi); vec2 <- sum(vec1)/2\nexpect_that(sortedmerge(vec1, vec2), equals(c(exp(1), vec2, pi)))\n\n## ------------------------ Exercise 05.03 ----------------------------\n\n## ---- Documentation ----\n# DESCRIPTION\n# This function removes all missing values from a given numeric vector.\n#\n# ARGUMENTS\n# x - a numeric vector\n#\n# RETURN VALUE\n# z - a numeric vector x with deleted missing values\n\n## ---- Function ----\n\nRcpp::cppFunction('\n  NumericVector naomit(const NumericVector x) {\n    int n = x.size();\n    int n_NA = sum(is_na(x));\n    NumericVector z(n - n_NA); //z is a vector x without NAs\n    for (int i=0, j=0; i<n; i++){\n      if(! NumericVector::is_na(x[i])) {\n        z[j] = x[i];\n        j++;\n      }\n    }\n  return z;\n  }\n')\n\n## ---- Examples ----\n\nexpect_that(naomit(c(NA, 6, NA, NA, 2, 6, NA)), equals(c(6,2,6)))\nexpect_that(naomit(c(NA, NA)), equals(numeric(0)))\nexpect_that(naomit(c(1.0, 3.1, 4.2, NA, 3, NA, 8)), equals(c(1.0, 3.1, 4.2, 3.0, 8.0)))\nexpect_that(naomit(c(NA, 2L, NA, 6L, NA)), equals(c(2,6)))\nexpect_that(naomit(c(3L, NaN, 0, NA)), equals(c(3,0))) #NaN like NA\nexpect_that(naomit(as.logical(c(0, 1, NA))), equals(c(0,1)))\nexpect_that(naomit(numeric(0)), equals(numeric(0)))\nexpect_that(naomit(logical(0)), equals(numeric(0)))\nexpect_that(naomit(raw(0)), equals(numeric(0)))\nexpect_that(naomit(as.complex(c(-1, 10, 0.5, NA, 0, NA, -1))), equals(c(-1,10,0.5,0,-1)))\nexpect_that(naomit(c(NA, 1, NA, NULL)), equals(1)) #NULL like NA\nexpect_that(naomit(c(\"a\", \"b\")), throws_error())\nexpect_that(naomit(c(TRUE, NA, Inf)), equals(c(1, Inf)))\n\n## ------------------------ Exercise 05.04 ----------------------------\n\n## ---- Documentation ----\n# DESCRIPTION\n# This function generates a random subvector of length k of a given\n# numeric vector x (without replacement, something like sample(x, k))\n#\n# ARGUMENTS\n# k - an integer number\n# x - a numeric vector\n#\n# RETURN VALUE\n# y - a random subvector of length k\n\n## ---- Function ----\nRcpp::cppFunction('\n  NumericVector sample2(int k, NumericVector x){ //Knuth algorithm for sampling without replacement\n    int n = x.size();\n    for (int i=0; i < n; i++) {   \n      if (R_IsNA(x[i]) || k > n) {\n        Rcpp::stop(\"Wrong input data\");\n      }\n    }\n    Rcpp::RNGScope scope;   \n    IntegerVector indices(k); //which indices of x are taken to the subvector\n    NumericVector y(k);\n    int t = 0; \n    int m = 0; \n    double u;\n    while (m < k) {\n      u = (double)rand()/(double)RAND_MAX;\n      if ((n - t)*u >= k - m) {\n        t++;\n      } else {\n        indices[m] = t;\n        t++; m++;\n      }\n    }\n    for (int i=0; i<k; i++){ //filling of the subvector\n      y[i] = x[indices[i]]; \n    }\n  return y;\n  }\n')\n\n## ---- Examples ----\n\nfor (i in 1:10) {print(sample2(4, 1:100))}\nsample2(3, c(1.2,2.5,3.6,7.4,pi,exp(1)))\nexpect_that(length(sample2(4, 1:100)), equals(4))\nexpect_that(sample2(1, c(Inf,Inf,Inf)), equals(Inf))\nexpect_that(sample2(0, c(1, 2)), equals(numeric(0)))\nexpect_that(sample2(1, NaN), equals(NaN))\nexpect_that(sample2(0, 0), equals(numeric(0)))\nexpect_that(sample2(0, raw(0)), equals(numeric(0)))\nexpect_that(sample2(1.8, 1), equals(1)) #floor for not integer k\nexpect_that(sample2(2, c(1, 2, NULL)), equals(c(1,2))) #NULL is considered as \"nothing\"\nexpect_that(sample2(3, c(1, 2, NULL)), throws_error()) #NULL is considered as \"nothing\"\nexpect_that(sample2(1, c(1, 2, NA)), throws_error()) #NA's handling\nexpect_that(sample2(3, c(1, 2)), throws_error()) #k is greater then the length of x\nexpect_that(sample2(-1, c(1, 2)), throws_error()) #k must be positive\n \n\n\n## ------------------------ Exercise 05.05 ----------------------------\n\n## ---- Documentation ----\n# DESCRIPTION\n# This function generates a random permutation of a given numeric vector.\n#\n# ARGUMENTS\n# x - a numeric vector\n#\n# RETURN VALUE\n# y - a random permutation of x\n\n## ---- Function ----\n\nRcpp::sourceCpp(code='\n#include <Rcpp.h>\n\ninline int WrapperPerm(const int n) {\n  return floor(unif_rand()*n);\n}\n\n// [[Rcpp::export]]\nRcpp::NumericVector randomperm(Rcpp::NumericVector x) {\n  int m = x.size();\n  for (int i=0; i < m; i++) {   \n    if (R_IsNA(x[i])) {\n      Rcpp::stop(\"Missing values not allowed\");\n    }\n  }\n  Rcpp::RNGScope scope;             \n  Rcpp::NumericVector y = Rcpp::clone(x);\n  std::random_shuffle(y.begin(), y.end(), WrapperPerm); //randomly rearranges elements\n  return y;\n}\n')\n\n## ---- Examples ----\n\na <- c(1:10, Inf)\nfor (i in 1:6) {print(randomperm(a))}\nexpect_that(randomperm(c(1,1,1)), equals(c(1,1,1)))\nexpect_that(randomperm(numeric(0)), equals(numeric(0)))\nexpect_that(randomperm(c(\"a\",\"b\")), throws_error())\nexpect_that(randomperm(TRUE), equals(1))\nexpect_that(length(unique(randomperm(a))), equals(length(unique(a))))\nexpect_that(randomperm(c(1,2,3,NA)), throws_error()) #NA's handling\nexpect_that(length(randomperm(c(1,2,3,NULL))), equals(3)) #NULLs with numbers are allowed (conversion)\nexpect_that(randomperm(logical(0)), equals(numeric(0)))\nexpect_that(randomperm(c(NULL,NULL)), throws_error()) #only NULLs are not allowed (not numeric type)\nexpect_that(randomperm(c(NaN, NaN)), equals(c(NaN, NaN))) #NaN allowed\n\n## ------------------------ Exercise 05.06 ----------------------------\n\n## ---- Documentation ----\n\n# \n\n\n## ---- Function ----\n\n#\n\n\n\n## ---- Examples ----\n\n# \n\n\n\n",
    "created" : 1422385602896.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3955526190",
    "id" : "82966AE6",
    "lastKnownWriteTime" : 1420893171,
    "path" : "C:/Users/Michał/Dropbox/Studia_doktoranckie/Przedmioty/Advanced Data Analysis Software Development with R/homework5_Michał_Pawłowski.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}